# CS Build Week 2: Interview Prep


### leetcode problem submissions  
---
## [contains-duplicate.py](https://github.com/CSLSDS/CS-Build-Week-2/blob/cs/contains-duplicate.py "contains-duplicate.py")  ðŸ“—easy  
> [https://leetcode.com/problems/contains-duplicate/]  
>> Given an array of integers, find if the array contains any duplicates.
>> 
>> Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.  
>> 
>> Example 1:
>> 
>> Input: [1,2,3,1]  
>> Output: true  

## [add-two-numbers.py](https://github.com/CSLSDS/CS-Build-Week-2/blob/cs/add-two-numbers.py "add-two-numbers.py")   ðŸ“™medium  
> [https://leetcode.com/problems/add-two-numbers/]  
>> You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
>> 
>> You may assume the two numbers do not contain any leading zero, except the number 0 itself.
>> 
>> Example:
>> 
>> Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)  
>> Output: 7 -> 0 -> 8  
>> Explanation: 342 + 465 = 807.  

## [two-sum.py](https://github.com/CSLSDS/CS-Build-Week-2/blob/cs/two-sum.py "two-sum.py")  ðŸ“—easy  
> [https://leetcode.com/problems/two-sum/]  
>> Given an array of integers nums and and integer target, return the indices of the two numbers such that they add up to target.
>> 
>> You may assume that each input would have exactly one solution, and you may not use the same element twice.
>> 
>> You can return the answer in any order.
>> 
>> Example 1:
>> 
>> Input: nums = [2,7,11,15], target = 9  
>> Output: [0,1]  
>> Output: Because nums[0] + nums[1] == 9, we return [0, 1]  

## [implement-queue-using-stacks.py](https://github.com/CSLSDS/CS-Build-Week-2/blob/cs/implement-queue-using-stacks.py "implement-queue-using-stacks.py")  ðŸ“—easy  
> [https://leetcode.com/problems/implement-queue-using-stacks/]  
>> Implement the following operations of a queue using stacks.
>> 
>> push(x) -- Push element x to the back of queue.  
>> pop() -- Removes the element from in front of queue.  
>> peek() -- Get the front element.  
>> empty() -- Return whether the queue is empty.  
>> Example:  
>> 
>> MyQueue queue = new MyQueue();  
>> 
>> queue.push(1);  
>> queue.push(2);  
>> queue.peek();  // returns 1  
>> queue.pop();   // returns 1  
>> queue.empty(); // returns false  

## [merge-two-sorted-lists.py](https://github.com/CSLSDS/CS-Build-Week-2/blob/cs/merge-two-sorted-lists.py "merge-two-sorted-lists.py")  ðŸ“—easy  
> [https://leetcode.com/problems/merge-two-sorted-lists/]  
>> Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.
>> 
>> Example:
>> 
>> Input: 1->2->4, 1->3->4  
>> Output: 1->1->2->3->4->4  

## [decode-string.py](https://github.com/CSLSDS/CS-Build-Week-2/blob/cs/decode-string.py "decode-string.py")  ðŸ“™medium  
> [https://leetcode.com/problems/decode-string/]   
>> Given an encoded string, return its decoded string.
>> 
>> The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.
>>  
>> You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.
>> 
>> Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].
>> 
>> Example 1:
>> 
>> Input: s = "3[a]2[bc]"  
>> Output: "aaabcbc"  
